"""
Enterprise-grade SQLAlchemy declarative model for the User entity.

Notes:
- Uses SQLAlchemy 2.0 style typing (Mapped, mapped_column).
- UUID primary key (Postgres PG_UUID) with python & server defaults.
- Includes avatar (URL string), locale, username, phone, phone verification flag,
  last_login_at, created_at, updated_at, is_active.
- Provides a reverse relationship 'social_accounts' to the SocialAccount model.
- Designed to be compatible with Alembic migrations (uses SQLAlchemy metadata).
"""

from __future__ import annotations

import uuid
from datetime import datetime
from typing import List, Optional

from sqlalchemy import Boolean, DateTime, Index, String, func, text
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

# Import your project's Base declarative (rename import as needed)
from app.core.models import Base  # <-- adjust if your Base is elsewhere


class User(Base):
    __tablename__ = "users"

    # Primary key: UUID (postgres native)
    id: Mapped[uuid.UUID] = mapped_column(
        PG_UUID(as_uuid=True),
        primary_key=True,
        nullable=False,
        server_default=text("gen_random_uuid()"),
    )

    # Core identity fields
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True, nullable=False)
    username: Mapped[Optional[str]] = mapped_column(String(50), unique=True, index=True, nullable=True)

    # Name fields (optional; keep a single 'name' if you prefer)
    name: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
    first_name: Mapped[Optional[str]] = mapped_column(String(128), nullable=True)
    last_name: Mapped[Optional[str]] = mapped_column(String(128), nullable=True)

    # Profile: avatar stored as a URL (string). Keep size small to avoid DB bloat.
    avatar: Mapped[Optional[str]] = mapped_column(String(1024), nullable=True)

    # Locale: BCP-47-like small string (e.g. "en-US", "pt-BR")
    locale: Mapped[Optional[str]] = mapped_column(String(20), nullable=True, index=True)

    # Phone number for MFA/OTP: store E.164 preferred (e.g. "+5511999999999")
    phone: Mapped[Optional[str]] = mapped_column(String(32), nullable=True, index=True)
    is_phone_verified: Mapped[bool] = mapped_column(
        Boolean,
        nullable=False,
        server_default=text("FALSE") # <-- IMPORTANT)
    )

    # Authentication & lifecycle
    is_email_verified: Mapped[bool] = mapped_column(
        Boolean,
        nullable=False,
        server_default=text("FALSE")
    )
    is_active: Mapped[bool] = mapped_column(
        Boolean,
        nullable=False,
        server_default=text("TRUE")
    )
    is_banned: Mapped[bool] = mapped_column(
        Boolean,
        nullable=False,
        server_default=text("FALSE")
    )

    # Timestamps
    #========================================================
    # created_at
    #========================================================
    """
    Requirements:
    - Immutable
    - Set once on INSERT
    - Must always be generated by DB (NOW() or CURRENT_TIMESTAMP)
    """
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(), # Enterprise: rely on DB, not Python
        nullable=False,
    )

    #========================================================
    # updated_at field
    #========================================================
    """
    Requirements:
    - Must auto-update on each row modification
    - Must NOT rely on application code to update it
    - Must be handled on the database side
    - Must be consistent no matter who performs the update (ORM, SQL, microservice, script, admin)
    
    ❌ WRONG approach (common mistakes):
    - Using onupdate=func.now() → only works for ORM writes (NOT raw SQL)
    - Updating via application manually

    ✔️ ENTERPRISE approach:
    - Use a PostgreSQL trigger that updates updated_at automatically on every UPDATE.

    -- 1. Create function
    CREATE OR REPLACE FUNCTION set_updated_at()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;
    
    -- 2. Attach trigger to table
    CREATE TRIGGER trigger_set_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION set_updated_at();
    """
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )

    #======================================================================
    # last_login_at - Useful for auditing, sessions cleanup, risk detection
    #======================================================================
    """
    Requirements:
    - Optional timestamp
    - Updated only when a login occurs
    - Must allow NULL values

    Should be set explicitly by your login flow (not by default)
    
    When updating:
    - Only update it in your login service, not via triggers.
    """
    last_login_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)

    # Relationship to social accounts (reverse of SocialAccount.user)
    # `social_accounts` model should set back_populates="user"
    social_accounts: Mapped[List["SocialAccount"]] = relationship(
        "SocialAccount",
        back_populates="user",
        cascade="all, delete-orphan",
        lazy="selectin",
    )

    # Place any additional relationships here (e.g., roles)
    user_roles: Mapped[List["UserRole"]] = relationship(
        "UserRole",
        back_populates="user",
        cascade="all, delete-orphan",
        lazy="selectin",
    )

    refresh_tokens: Mapped[list["RefreshToken"]] = relationship(
        "RefreshToken",
        back_populates="user",
        cascade="all, delete-orphan",
        lazy="selectin",
    )

    audit_logs: Mapped[list["AuditLog"]] = relationship(
        "AuditLog",
        back_populates="user",
        lazy="selectin",
    )

    # Create helpful indices at DB level for common lookups (adjust if using Alembic)
    __table_args__ = (
        Index("ix_users_email", "email"),
        Index("ix_users_username", "username"),
        Index("ix_users_phone", "phone"),
    )

    def __repr__(self) -> str:
        return f"<User(id={self.id!s} email={self.email!s} username={self.username!s})>"

    def to_dict(self) -> dict:
        """
        Lightweight dict representation for logs or internal APIs.
        Avoid leaking PII to logs in production.
        """
        return {
            "id": str(self.id) if self.id else None,
            "email": self.email,
            "username": self.username,
            "name": self.name,
            "first_name": self.first_name,
            "last_name": self.last_name,
            "avatar": self.avatar,
            "locale": self.locale,
            "phone": self.phone,
            "is_phone_verified": self.is_phone_verified,
            "is_email_verified": self.is_email_verified,
            "is_active": self.is_active,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
            "last_login_at": self.last_login_at.isoformat() if self.last_login_at else None,
        }
